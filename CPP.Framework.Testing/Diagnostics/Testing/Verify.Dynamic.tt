<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="Microsoft.CSharp" #>
<#@ assembly name="Microsoft.VisualStudio.QualityTools.UnitTestFramework, Version=10.0.0" #>
<#@ assembly name="System.Xml" #>
<#@ assembly name="System.Xml.Linq" #>
<#@ assembly name="System.Xml.XDocument" #>
<#@ import namespace="System.CodeDom" #>
<#@ import namespace="System.CodeDom.Compiler" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Globalization" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Reflection" #>
<#@ import namespace="System.Xml.Linq" #>
<#@ import namespace="System.Xml.XPath" #>
<#@ import namespace="Microsoft.CSharp" #>
<#@ import namespace="Microsoft.Win32" #>
<#@ output extension=".cs" #>
<#
    var declaration = new CodeTypeDeclaration("Verify")
    {
        Attributes = (MemberAttributes.Public | MemberAttributes.Static),
        IsClass = true,
        IsPartial = true,
    };
    declaration.Comments.AddRange(new []
    {
        new CodeCommentStatement("<summary>", true),
        new CodeCommentStatement("Verifies conditions in unit tests using true/false propositions. This class contains a ", true),
        new CodeCommentStatement("superset of methods provided by the built-in <see cref=\"Assert\"/> class.", true),
        new CodeCommentStatement("</summary>", true),
    });
    var target = typeof(Microsoft.VisualStudio.TestTools.UnitTesting.Assert);
    var xmldoc = OpenDocumentationFile(target.Assembly);

    foreach (var mi in target.GetMethods(BindingFlags.Static | BindingFlags.Public | BindingFlags.DeclaredOnly))
    {
        var attributes = (MemberAttributes.Public | MemberAttributes.Static);
        var parameters = mi.GetParameters().OrderBy(ai => ai.Position);
        if (mi.IsHideBySig && (mi.DeclaringType.BaseType.GetMethod(mi.Name, parameters.Select(pi => pi.ParameterType).ToArray()) != null))
        {
            attributes |= (MemberAttributes.New);
        }
        var method = new CodeMemberMethod();
        method.Name = mi.Name;
        method.ReturnType = new CodeTypeReference(mi.ReturnType);        
        method.Attributes = attributes;
        method.Comments.AddRange(GetMemberDocumentationComments(xmldoc, mi).ToArray());

        var reference = new CodeTypeReferenceExpression(mi.DeclaringType.Name);
        var invoke = new CodeMethodInvokeExpression(new CodeMethodReferenceExpression(reference, mi.Name));

        var typeParamNames = new HashSet<string>();
        foreach (var ai in parameters)
        {
            if (ai.ParameterType.IsGenericParameter)
            {
                var name = ai.ParameterType.Name;
                if (typeParamNames.Add(name))
                {
                    method.TypeParameters.Add(new CodeTypeParameter(name));
                }
            }
            method.Parameters.Add(new CodeParameterDeclarationExpression(ai.ParameterType, ai.Name));
            invoke.Parameters.Add(new CodeArgumentReferenceExpression(ai.Name));
        }

        if (mi.ReturnType != typeof(void))
        {
            method.Statements.Add(new CodeMethodReturnStatement(invoke));
        }
        else method.Statements.Add(invoke);

        declaration.Members.Add(method);
    }

    var block = new CodeCompileUnit();
    block.Namespaces.Add(new CodeNamespace("CPP.Framework.Diagnostics.Testing"));
    block.Namespaces[0].Imports.AddRange(new []
    {
        new CodeNamespaceImport("Microsoft.VisualStudio.TestTools.UnitTesting"),
    });
    block.Namespaces[0].Types.Add(declaration);

    var options = new CodeGeneratorOptions
    {
        BlankLinesBetweenMembers = false,
        BracingStyle = "C",
        IndentString = "    ",
    };
    var writer = new System.IO.StringWriter();
    var compiler = new CSharpCodeProvider();
    compiler.GenerateCodeFromCompileUnit(block, writer, options);
#>
<#=(writer.ToString())#>
<#+
    public IEnumerable<CultureInfo> EnumerateCultureInfo(CultureInfo culture)
    {
        for (CultureInfo ci = culture; (ci != null);)
        {
            yield return culture;
            ci = ((ci.Parent.Name != ci.Name) ? ci.Parent : null);
        }
    }
    public string FormatTypeForDocumentationID(Type ti, List<string> openGenericArgs)
    {
        if (ti.IsGenericType)
        {
            var typeName = ti.Name;
            if (typeName.IndexOf('`') >= 0)
            {
                typeName = typeName.Substring(0, typeName.IndexOf('`'));
            }
            var container = (ti.IsNested ? FormatTypeForDocumentationID(ti.DeclaringType, openGenericArgs) : ti.Namespace);

            var sb = new System.Text.StringBuilder();
            sb.AppendFormat("{0}.{1}", container, typeName);
            sb.Append("{");
            foreach(var pi in ti.GetGenericArguments())
            {
                sb.AppendFormat("{0},", FormatTypeForDocumentationID(pi, openGenericArgs));
            }
            sb.Length--;
            sb.Append("}");

            return sb.ToString();
        }
        else
        {
            var typeName = ti.FullName;
            if (ti.IsGenericParameter)
            {
                var index = openGenericArgs.IndexOf(ti.Name);
                if (index == -1)
                {
                    index = openGenericArgs.Count;
                    openGenericArgs.Add(ti.Name);
                }
                typeName = String.Format("``{0}", index);
            }
            return typeName;
        }
    }
    public IEnumerable<string> GetFallbackLocations(string location, string filename)
    {
        for (CultureInfo ci = CultureInfo.CurrentCulture; (ci != null);)
        {
            var candidate = Path.Combine(location, ci.Name, filename);
            candidate = Environment.ExpandEnvironmentVariables(candidate);
            if (File.Exists(candidate)) yield return candidate;
            ci = ((ci.Parent.Name != ci.Name) ? ci.Parent : null);
        }
    }
    public string GetMemberDocumentationID(MemberInfo info)
    {
        var prefix = default(char);
        var member = ((info is Type)
            ? (((Type)info).FullName)
            : (String.Join(".", info.DeclaringType.FullName, info.Name)));
        switch (info.MemberType)
        {
            case MemberTypes.Constructor:
                member = member.Replace(".ctor", "#ctor");
                goto case MemberTypes.Method;
            case MemberTypes.Method:
                prefix = 'M';
                var methodArgs = new System.Text.StringBuilder();
                var typeParams = new List<string>();
                foreach (var pi in ((MethodBase)info).GetParameters())
                {
                    if (methodArgs.Length >= 1) methodArgs.Append(",");
                    methodArgs.Append(FormatTypeForDocumentationID(pi.ParameterType, typeParams));
                }
                if (typeParams.Count >= 1) member += ("``" + typeParams.Count);
                if (methodArgs.Length >= 1) member += ("(" + methodArgs + ")");
                break;
            case MemberTypes.NestedType:
                member = member.Replace('+', '.');
                goto case MemberTypes.TypeInfo;
            case MemberTypes.TypeInfo: prefix = 'T'; break;
            case MemberTypes.Event: prefix = 'E'; break;
            case MemberTypes.Field: prefix = 'F'; break;
            case MemberTypes.Property: prefix = 'P'; break;
            default: throw new ArgumentException("Unknown member type.", "info");
        }
        return String.Format("{0}:{1}", prefix, member);
    }
    public IEnumerable<CodeCommentStatement> GetMemberDocumentationComments(XDocument document, MemberInfo info)
    {
        var member = GetMemberDocumentationID(info);
        var xpath = String.Format("/doc/members/member[@name='{0}']/*", member);
        var sequence = document.XPathSelectElements(xpath)
            .Select(elem => elem.ToString(SaveOptions.None))
            .Select(text => new CodeCommentStatement(text, true));
        return sequence;
    }
    public XDocument OpenDocumentationFile(Assembly assembly)
    {
        var framework = assembly.ImageRuntimeVersion;
        var locations = new List<string>
        {
            (Path.GetDirectoryName(assembly.CodeBase)),
            (Path.GetDirectoryName(assembly.Location)),
            (Path.Combine(@"%ProgramFiles(x86)%\Reference Assemblies\Microsoft\Framework", ".NETCore", framework)),
            (Path.Combine(@"%ProgramFiles(x86)%\Reference Assemblies\Microsoft\Framework", ".NETFramework", framework)),
            (Path.Combine(@"%ProgramFiles(x86)%\Reference Assemblies\Microsoft\Framework", framework)),
        };
        using (var root = Registry.LocalMachine.OpenSubKey(@"Software\Microsoft\VisualStudio"))
        {
            foreach (var name in root.GetSubKeyNames().OrderByDescending(n => n))
            {
                using (var vskey = root.OpenSubKey(name))
                {
                    var installDir = (vskey.GetValue("InstallDir") as string);
                    if (String.IsNullOrWhiteSpace(installDir)) continue;
                    locations.Add(Path.Combine(installDir, "PublicAssemblies"));
                }
            }
        }
        var filename = (Path.GetFileNameWithoutExtension(assembly.Location) + ".xml");
        
        var candidate = locations.SelectMany(path => GetFallbackLocations(path, filename)).First();
        return XDocument.Load(candidate);
    }
#>